# Sleigh specification for u'nSP

define endian=little;
define alignment=2;


# 22 bit address space -> size=3
# Each address accesses 16 bits (2x8) -> wordsize=2
define space ram type=ram_space size=3 wordsize=2 default;
define space register type=register_space size=2;

# General purpose Registers
# bp is sometimes called r5
define register offset=0 size=2     [ sp r1 r2 r3 r4 bp ];

# Status register
# We'll only update sr when it's accessed
define register offset=0xc size=2    [ sr ];

# Status register components
# Store these discretely, modelling after the ARM SLEIGH spec
define register offset=0x10 size=1   [ C_flag S_flag Z_flag N_flag ds ];

# Program counter
# In reality, there is no pc_full, only pc and cs, which is the upper 6 bits of the address
# The call instruction is cross-bank, as are goto's
# And the program counter will naturally cross banks i.e. 0x4ffff + 1 -> 0x50000
# In order for calls and gotos to work correctly, we use this fake register. Unfortunately,
# this makes contents of cs incorrect.
# Until Sleigh adds composite registers (or we find a better solution) this will remain.
# ---
# Use pc_full as actual program counter, and pc for pushing to stack
# Separate them from sr so Ghidra advancing instruction pointer does not affect
# value of other things
define register offset=0x15 size=3    [ pc_full ];
define register offset=0x15 size=2    [ pc ];
define register offset=0x17 size=1    [ cs ];

# Flag register (since u'nSP 1.2)
define register offset=0x20 size=2    [ fr ];

# Flag register components
define register offset=0x30 size=1    [ irqnest irq fiq fir_mov fraction sec_bank aq ];
define register offset=0x37 size=1    [ pri sb ];

# Second bank (since u'nSP 1.2)
define register offset=0x40 size=2  [ sr1 sr2 sr3 sr4 ];
# TODO: hook them up

# u'nSP 1.3-specific registers
# TODO: hook them up
define register offset=0x22 size=2  [ ss_full mds ];
# SS register is only 6 bits, but chances are the storage is 16 bits
@define ss "ss_full[0,6]"

# Extended registers (u'nSP 2.0)
define register offset=0x50 size=2 [ r8 r9 r10 r11 r12 r13 r14 r15 ];

# Context for extended instructions
# See https://github.com/NationalSecurityAgency/ghidra/issues/2365
#define context contextreg
#    isExtended=(0,0) # 0:initial, 1:instruction-parse
#;

define token instr(16)
    op0=(12, 15)
    opA_r=(9, 11)
    opA_nosr=(9, 11)
    opA_v=(9, 11)
    opA_p=(9, 11)
    
    op1=(6, 8)
    opN=(3, 5)
        opFlag=(5, 5)
        opShift=(3, 4)
    opB_r=(0, 2)
    opB_nosr=(0, 2)
    opB_v=(0, 2)
    opimm=(0, 5)

    opE1=(7, 8)
    opE2=(4, 6)

    opBitFn=(4, 5)
    opBitFlg=(3, 3)
    opBitN=(0, 3)
;

attach variables [ opA_r opB_r ] [ sp r1 r2 r3 r4 bp sr pc ];
attach variables [ opA_nosr opB_nosr ] [ sp r1 r2 r3 r4 bp _ pc ];
# Bizarrely shifted
attach variables [ opA_p ] [ r1 r2 r3 r4 bp sr pc _ ];

define token immtoken(16)
    imm16=(0,15);

define pcodeop segment;    # Define special pcodeop that calculates the RAM address
                           # given the segment selector and offset as input
define pcodeop exp;

# Tables for level of indirection so SR can be packed and unpacked
UnpackSR: is epsilon {
    local tmp_ds = (sr >> 10) & 0x3f;
    local tmp_cs = sr & 0x3f;

    ds = tmp_ds:1;
    # Done same way as in ARM `msr cpsr,rm`
    N_flag = ((sr >> 9) & 0x1) != 0;
    Z_flag = ((sr >> 8) & 0x1) != 0;
    S_flag = ((sr >> 7) & 0x1) != 0;
    C_flag = ((sr >> 6) & 0x1) != 0;
    cs = tmp_cs:1;
}

PackSR: is epsilon {
    sr = 
        (zext(ds) << 10) |
        (zext(N_flag) << 9) |
        (zext(Z_flag) << 8) |
        (zext(S_flag) << 7) |
        (zext(C_flag) << 6) |
        zext(cs[0,6]);
    export sr;
}

UnpackSR_opA: is opA_v=6 & UnpackSR { }
UnpackSR_opA: is opA_v!=6 { }

opA: opA_r is opA_r { export opA_r; }

opARead: sr is sr & opA_v=6 & PackSR { export PackSR; }
opARead: opA is opA { export opA; }

opB: sr is sr & opB_v=6 & PackSR { export PackSR; }
opB: opB_r is opB_r { export opB_r; }

# Macros

macro push(x) {
    local data:2 = x;
    local stack_addr:3 = segment(0:1, sp);
    *:2 stack_addr = data;
    sp = sp - 1;
}

macro setResultFlags(reg) {
    Z_flag = (reg == 0);
    N_flag = (reg s< 0);
}

# Following adapted from x86 processor
# Must be called after setResultFlags() due to dependence on N_flag

# I have no idea how the sign flag is actually supposed to be calculated,
# but according to the u'nSP programmer's guide overflow occurs when N and S
# are different, so let's set per overflow

macro setAddFlags(op1,op2) {
    local of = scarry(op1, op2);
    C_flag = carry(op1, op2);
    S_flag = of ^^ N_flag;
}

macro setAddCarryFlags(op1,op2) {
	local CFcopy = zext(C_flag);
	local cf = carry(op1, op2);
    local of = scarry(op1, op2);
    local result = op1 + op2;
	cf = cf || carry(result, CFcopy);
    of = of ^^ scarry(result, CFcopy);
    C_flag = cf;
	S_flag = of ^^ N_flag;
}

macro setSubtractFlags(op1,op2) {
    local of = sborrow(op1, op2);
    C_flag = carry(op1, ~op2);
	S_flag = of ^^ N_flag;
}

macro setSubtractCarryFlags(op1,op2) {
	local CFcopy = C_flag;
    # For carry, use original `a + ~b + C`
    # For borrow, use `a - b - !C`
	local cf = carry(op1, ~op2);
    local of = sborrow(op1, op2);
    # Operation before carry is `op1 + ~op2`
	local result = op1 - op2;
    # a - b == a + ~b + 1, need to remove the 1
	cf = cf || carry(result - 1, zext(CFcopy));
    of = of ^^ sborrow(result, zext(!CFcopy));
    C_flag = cf;
	S_flag = of ^^ N_flag;
}

# Instructions

# Jumps
# Local to a bank, will wrap around (unlike call/goto)

# Positive jump with 6bit immediate
RelP6:   relAddr is opimm [ relAddr=(inst_start & 0x3f0000) + ((inst_next+opimm) & 0xffff); ] { export *:3 relAddr; }
# Negative jump with 6bit immediate
RelN6:   relAddr is opimm [ relAddr=(inst_start & 0x3f0000) + ((inst_next-opimm) & 0xffff); ] { export *:3 relAddr; }

# Conditions
cc: "b"  is op0=0x0     { local tmp = !C_flag; export tmp; }
cc: "ae" is op0=0x1     { export C_flag; }
cc: "ge" is op0=0x2     { local tmp = !S_flag; export tmp; }
cc: "l"  is op0=0x3     { export S_flag; }
cc: "ne" is op0=0x4     { local tmp = !Z_flag; export tmp; }
cc: "e"  is op0=0x5     { export Z_flag; }
cc: "pl" is op0=0x6     { local tmp = !N_flag; export tmp; }
cc: "mi" is op0=0x7     { export N_flag; }
cc: "be" is op0=0x8     { local tmp = Z_flag || !C_flag; export tmp; }
cc: "a"  is op0=0x9     { local tmp = !Z_flag && C_flag; export tmp; }
cc: "le" is op0=0xa     { local tmp = Z_flag || S_flag; export tmp; }
cc: "g"  is op0=0xb     { local tmp = !Z_flag && !S_flag; export tmp; }
cc: "vc" is op0=0xc     { local tmp = N_flag == S_flag; export tmp; }
cc: "vs" is op0=0xd     { local tmp = N_flag != S_flag; export tmp; }

:j^cc RelP6 is opA_v=7 & cc & op1=0 & RelP6 {
    if(cc) goto RelP6;
}
:j^cc RelN6 is opA_v=7 & cc & op1=1 & RelN6 {
    if(cc) goto RelN6;
}
:jmp RelP6 is opA_v=7 & op0=0xe & op1=0 & RelP6 {
    goto RelP6;
}
:jmp RelN6 is opA_v=7 & op0=0xe & op1=1 & RelN6 {
    goto RelN6;
}

# ALU6

IndirectOp: ""[opB] is opN=0 & opB {
    export *:2 opB;
} 
IndirectOp: ""[opB--] is opN=1 & opB {
    local tmp = opB;
    opB = opB - 1;
    export *:2 tmp;
} 
IndirectOp: ""[opB++] is opN=2 & opB {
    local tmp = opB;
    opB = opB + 1;
    export *:2 tmp;
} 
IndirectOp: ""[++opB] is opN=3 & opB {
    opB = opB + 1;
    export *:2 opB;
} 
IndirectOp: "ds":[opB] is opN=4 & opB {
    local addr:3 = segment(ds, opB);
    export *:2 addr;
} 
IndirectOp: "ds":[opB--] is opN=5 & opB {
    local addr:3 = segment(ds, opB);
    ds = ds - sborrow(opB, 1);
    opB = opB - 1;
    export *:2 addr;
} 
IndirectOp: "ds":[opB++] is opN=6 & opB {
    local addr:3 = segment(ds, opB);
    ds = ds + scarry(opB, 1);
    opB = opB + 1;
    export *:2 addr;
} 
IndirectOp: "ds":[++opB] is opN=7 & opB {
    ds = ds + scarry(opB, 1);
    opB = opB + 1;
    local addr:3 = segment(ds, opB);
    export *:2 addr;
}
# ALU with base+displacement
ALU6BaseDisplacement: ["bp"+opimm] is op1=0 & opimm {
    # Stack is always located in Bank 0
    local stack_addr:3 = segment(0:1, bp+opimm);
    local term = *:2 stack_addr;
    export term;
}
# ALU with 6bit immediate
ALU6Opimm: opimm is opimm { local tmp:2 = opimm; export tmp; }
ALU6Reg: opB is opB { local tmp:2 = opB; export tmp; } 
ALU6Mem: ""[opimm] is opimm { export *:2 opimm; }
ALU6RShift: opB "asr" shift is opShift & opB [ shift = opShift + 1; ] {
    # Save shifted out bits in sb
    local tmp = (opB:1 << 4) | sb;
    tmp = tmp >> shift;
    sb = tmp & 0xf:1;

    local val:2 = opB s>> shift; 
    export val;
}
ALU6LShift: opB "lsl" shift is opFlag=0 & opShift & opB [ shift = opShift + 1; ] {
    # Save shifted out bits in sb
    local tmp = (sb << 8) | opB(1);
    tmp = tmp >> (8 - shift);
    sb = tmp & 0xf:1;

    local val:2 = opB << shift;
    export val;
}
ALU6LShift: opB "lsr" shift is opFlag=1 & opShift & opB [ shift = opShift + 1; ] {
    # Save shifted out bits in sb
    local tmp = (opB:1 << 4) | sb;
    tmp = tmp >> shift;
    sb = tmp & 0xf:1;

    local val:2 = opB >> shift; 
    export val;
}
ALU6RotShift: opB "rol" shift is opFlag=0 & opShift & opB [ shift = opShift + 1; ] {
    local val:2 = opB << shift;
    val = val | zext(sb);

    # Save shifted out bits in sb
    local tmp = (sb << 8) | opB(1);
    tmp = tmp >> (8 - shift);
    sb = tmp & 0xf:1;

    export val;
}
ALU6RotShift: opB "ror" shift is opFlag=1 & opShift & opB [ shift = opShift + 1; ] {
    local tmpVal:3 = (zext(sb) << 16) | zext(opB);
    tmpVal = tmpVal >> shift;
    local val = tmpVal:2;

    # Save shifted out bits in sb
    local tmp = (opB:1 << 4) | sb;
    tmp = tmp >> shift;
    sb = tmp & 0xf:1;

    export val;
}
ALU6DstStack: ""["bp"+opimm] is op1=0 & opimm {
    # Stack is always located in Bank 0
    local stack_addr:3 = segment(0:1, bp+opimm);
    export *:2 stack_addr;
}

# TODO: do not set flags if destination is PC

# r1 += 7
:^opA += ALU6BaseDisplacement is op0=0 & op1=0 & opA & UnpackSR_opA & ALU6BaseDisplacement {
    local origOpA:2 = opA;
    opA = opA + ALU6BaseDisplacement;
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddFlags(origOpA, ALU6BaseDisplacement);
}
:^opA += ALU6Opimm is op0=0 & op1=1 & opA & UnpackSR_opA & ALU6Opimm {
    local origOpA:2 = opA;
    opA = opA + ALU6Opimm;
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddFlags(origOpA, ALU6Opimm);
}
:^opA += IndirectOp is op0=0 & op1=3 & opA & UnpackSR_opA & IndirectOp {
    local origOpA:2 = opA;
    opA = opA + IndirectOp;
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddFlags(origOpA, IndirectOp);
}
:^opA += ALU6Reg is op0=0 & op1=4 & opN=0 & opA & UnpackSR_opA & ALU6Reg {
    local origOpA:2 = opA;
    opA = opA + ALU6Reg;
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddFlags(origOpA, ALU6Reg);
}
:^opA += ALU6RShift is op0=0 & op1=4 & opFlag=1 & opA & UnpackSR_opA & ALU6RShift {
    local origOpA:2 = opA;
    opA = opA + ALU6RShift;
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddFlags(origOpA, ALU6RShift);
}
:^opA += ALU6LShift is op0=0 & op1=5 & opA & UnpackSR_opA & ALU6LShift {
    local origOpA:2 = opA;
    opA = opA + ALU6LShift;
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddFlags(origOpA, ALU6LShift);
}
:^opA += ALU6RotShift is op0=0 & op1=6 & opA & UnpackSR_opA & ALU6RotShift {
    local origOpA:2 = opA;
    opA = opA + ALU6RotShift;
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddFlags(origOpA, ALU6RotShift);
}
:^opA += ALU6Mem is op0=0 & op1=7 & opA & UnpackSR_opA & ALU6Mem {
    local origOpA:2 = opA;
    opA = opA + ALU6Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddFlags(origOpA, ALU6Mem);
}

# r1 += 7, carry
:^opA += ALU6BaseDisplacement, "carry" is op0=1 & op1=0 & opA & UnpackSR_opA & ALU6BaseDisplacement {
    local origOpA:2 = opA;
    opA = opA + ALU6BaseDisplacement + zext(C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddCarryFlags(origOpA, ALU6BaseDisplacement);
}
:^opA += ALU6Opimm, "carry" is op0=1 & op1=1 & opA & UnpackSR_opA & ALU6Opimm {
    local origOpA:2 = opA;
    opA = opA + ALU6Opimm + zext(C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddCarryFlags(origOpA, ALU6Opimm);
}
:^opA += IndirectOp, "carry" is op0=1 & op1=3 & opA & UnpackSR_opA & IndirectOp {
    local origOpA:2 = opA;
    opA = opA + IndirectOp + zext(C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddCarryFlags(origOpA, IndirectOp);
}
:^opA += ALU6Reg, "carry" is op0=1 & op1=4 & opN=0 & opA & UnpackSR_opA & ALU6Reg {
    local origOpA:2 = opA;
    opA = opA + ALU6Reg + zext(C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddCarryFlags(origOpA, ALU6Reg);
}
:^opA += ALU6RShift, "carry" is op0=1 & op1=4 & opFlag=1 & opA & UnpackSR_opA & ALU6RShift {
    local origOpA:2 = opA;
    opA = opA + ALU6RShift + zext(C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddCarryFlags(origOpA, ALU6RShift);
}
:^opA += ALU6LShift, "carry" is op0=1 & op1=5 & opA & UnpackSR_opA & ALU6LShift {
    local origOpA:2 = opA;
    opA = opA + ALU6LShift + zext(C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddCarryFlags(origOpA, ALU6LShift);
}
:^opA += ALU6RotShift, "carry" is op0=1 & op1=6 & opA & UnpackSR_opA & ALU6RotShift {
    local origOpA:2 = opA;
    opA = opA + ALU6RotShift + zext(C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddCarryFlags(origOpA, ALU6RotShift);
}
:^opA += ALU6Mem, "carry" is op0=1 & op1=7 & opA & UnpackSR_opA & ALU6Mem {
    local origOpA:2 = opA;
    opA = opA + ALU6Mem + zext(C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddCarryFlags(origOpA, ALU6Mem);
}

# r1 -= 7
:^opA -= ALU6BaseDisplacement is op0=2 & op1=0 & opA & UnpackSR_opA & ALU6BaseDisplacement  {
    local origOpA:2 = opA;
    opA = opA - ALU6BaseDisplacement;
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractFlags(origOpA, ALU6BaseDisplacement);
}
:^opA -= ALU6Opimm is op0=2 & op1=1 & opA & UnpackSR_opA & ALU6Opimm  {
    local origOpA:2 = opA;
    opA = opA - ALU6Opimm;
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractFlags(origOpA, ALU6Opimm);
}
:^opA -= IndirectOp is op0=2 & op1=3 & opA & UnpackSR_opA & IndirectOp  {
    local origOpA:2 = opA;
    opA = opA - IndirectOp;
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractFlags(origOpA, IndirectOp);
}
:^opA -= ALU6Reg is op0=2 & op1=4 & opN=0 & opA & UnpackSR_opA & ALU6Reg  {
    local origOpA:2 = opA;
    opA = opA - ALU6Reg;
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractFlags(origOpA, ALU6Reg);
}
:^opA -= ALU6RShift is op0=2 & op1=4 & opFlag=1 & opA & UnpackSR_opA & ALU6RShift  {
    local origOpA:2 = opA;
    opA = opA - ALU6RShift;
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractFlags(origOpA, ALU6RShift);
}
:^opA -= ALU6LShift is op0=2 & op1=5 & opA & UnpackSR_opA & ALU6LShift  {
    local origOpA:2 = opA;
    opA = opA - ALU6LShift;
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractFlags(origOpA, ALU6LShift);
}
:^opA -= ALU6RotShift is op0=2 & op1=6 & opA & UnpackSR_opA & ALU6RotShift  {
    local origOpA:2 = opA;
    opA = opA - ALU6RotShift;
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractFlags(origOpA, ALU6RotShift);
}
:^opA -= ALU6Mem is op0=2 & op1=7 & opA & UnpackSR_opA & ALU6Mem  {
    local origOpA:2 = opA;
    opA = opA - ALU6Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractFlags(origOpA, ALU6Mem);
}
# r1 -= 7, carry
:^opA -= ALU6BaseDisplacement, "carry" is op0=3 & op1=0 & opA & UnpackSR_opA & ALU6BaseDisplacement  {
    local origOpA:2 = opA;
    opA = opA - ALU6BaseDisplacement - zext(!C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractCarryFlags(origOpA, ALU6BaseDisplacement);
}
:^opA -= ALU6Opimm, "carry" is op0=3 & op1=1 & opA & UnpackSR_opA & ALU6Opimm  {
    local origOpA:2 = opA;
    opA = opA - ALU6Opimm - zext(!C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractCarryFlags(origOpA, ALU6Opimm);
}
:^opA -= IndirectOp, "carry" is op0=3 & op1=3 & opA & UnpackSR_opA & IndirectOp  {
    local origOpA:2 = opA;
    opA = opA - IndirectOp - zext(!C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractCarryFlags(origOpA, IndirectOp);
}
:^opA -= ALU6Reg, "carry" is op0=3 & op1=4 & opN=0 & opA & UnpackSR_opA & ALU6Reg  {
    local origOpA:2 = opA;
    opA = opA - ALU6Reg - zext(!C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractCarryFlags(origOpA, ALU6Reg);
}
:^opA -= ALU6RShift, "carry" is op0=3 & op1=4 & opFlag=1 & opA & UnpackSR_opA & ALU6RShift  {
    local origOpA:2 = opA;
    opA = opA - ALU6RShift - zext(!C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractCarryFlags(origOpA, ALU6RShift);
}
:^opA -= ALU6LShift, "carry" is op0=3 & op1=5 & opA & UnpackSR_opA & ALU6LShift  {
    local origOpA:2 = opA;
    opA = opA - ALU6LShift - zext(!C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractCarryFlags(origOpA, ALU6LShift);
}
:^opA -= ALU6RotShift, "carry" is op0=3 & op1=6 & opA & UnpackSR_opA & ALU6RotShift  {
    local origOpA:2 = opA;
    opA = opA - ALU6RotShift - zext(!C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractCarryFlags(origOpA, ALU6RotShift);
}
:^opA -= ALU6Mem, "carry" is op0=3 & op1=7 & opA & UnpackSR_opA & ALU6Mem  {
    local origOpA:2 = opA;
    opA = opA - ALU6Mem - zext(!C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractCarryFlags(origOpA, ALU6Mem);
}

# cmp r1, 7
:cmp opARead, ALU6BaseDisplacement is op0=4 & op1=0 & opARead & ALU6BaseDisplacement  {
    local res = opARead - ALU6BaseDisplacement;
    setResultFlags(res);
    setSubtractFlags(opARead, ALU6BaseDisplacement);
}
:cmp opARead, ALU6Opimm is op0=4 & op1=1 & opARead & ALU6Opimm  {
    local res = opARead - ALU6Opimm;
    setResultFlags(res);
    setSubtractFlags(opARead, ALU6Opimm);
}
:cmp opARead, IndirectOp is op0=4 & op1=3 & opARead & IndirectOp  {
    local res = opARead - IndirectOp;
    setResultFlags(res);
    setSubtractFlags(opARead, IndirectOp);
}
:cmp opARead, ALU6Reg is op0=4 & op1=4 & opN=0 & opARead & ALU6Reg  {
    local res = opARead - ALU6Reg;
    setResultFlags(res);
    setSubtractFlags(opARead, ALU6Reg);
}
:cmp opARead, ALU6RShift is op0=4 & op1=4 & opFlag=1 & opARead & ALU6RShift  {
    local res = opARead - ALU6RShift;
    setResultFlags(res);
    setSubtractFlags(opARead, ALU6RShift);
}
:cmp opARead, ALU6LShift is op0=4 & op1=5 & opARead & ALU6LShift  {
    local res = opARead - ALU6LShift;
    setResultFlags(res);
    setSubtractFlags(opARead, ALU6LShift);
}
:cmp opARead, ALU6RotShift is op0=4 & op1=6 & opARead & ALU6RotShift  {
    local res = opARead - ALU6RotShift;
    setResultFlags(res);
    setSubtractFlags(opARead, ALU6RotShift);
}
:cmp opARead, ALU6Mem is op0=4 & op1=7 & opARead & ALU6Mem  {
    local res = opARead - ALU6Mem;
    setResultFlags(res);
    setSubtractFlags(opARead, ALU6Mem);
} 
# r1 = -7
:^opA = -ALU6BaseDisplacement is op0=6 & op1=0 & opA & UnpackSR_opA & ALU6BaseDisplacement  {
    opA = -ALU6BaseDisplacement;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = -ALU6Opimm is op0=6 & op1=1 & opA & UnpackSR_opA & ALU6Opimm  {
    opA = -ALU6Opimm;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = -IndirectOp is op0=6 & op1=3 & opA & UnpackSR_opA & IndirectOp  {
    opA = -IndirectOp;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = -ALU6Reg is op0=6 & op1=4 & opN=0 & opA & UnpackSR_opA & ALU6Reg  {
    opA = -ALU6Reg;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = -ALU6RShift is op0=6 & op1=4 & opFlag=1 & opA & UnpackSR_opA & ALU6RShift  {
    opA = -ALU6RShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = -ALU6LShift is op0=6 & op1=5 & opA & UnpackSR_opA & ALU6LShift  {
    opA = -ALU6LShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = -ALU6RotShift is op0=6 & op1=6 & opA & UnpackSR_opA & ALU6RotShift  {
    opA = -ALU6RotShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = -ALU6Mem is op0=6 & op1=7 & opA & UnpackSR_opA & ALU6Mem  {
    opA = -ALU6Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
}
# r1 ^= 7
:^opA "^"= ALU6BaseDisplacement is op0=8 & op1=0 & opA & UnpackSR_opA & ALU6BaseDisplacement  {
    opA = opA ^ ALU6BaseDisplacement;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA "^"= ALU6Opimm is op0=8 & op1=1 & opA & UnpackSR_opA & ALU6Opimm  {
    opA = opA ^ ALU6Opimm;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA "^"= IndirectOp is op0=8 & op1=3 & opA & UnpackSR_opA & IndirectOp  {
    opA = opA ^ IndirectOp;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA "^"= ALU6Reg is op0=8 & op1=4 & opN=0 & opA & UnpackSR_opA & ALU6Reg  {
    opA = opA ^ ALU6Reg;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA "^"= ALU6RShift is op0=8 & op1=4 & opFlag=1 & opA & UnpackSR_opA & ALU6RShift  {
    opA = opA ^ ALU6RShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA "^"= ALU6LShift is op0=8 & op1=5 & opA & UnpackSR_opA & ALU6LShift  {
    opA = opA ^ ALU6LShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA "^"= ALU6RotShift is op0=8 & op1=6 & opA & UnpackSR_opA & ALU6RotShift  {
    opA = opA ^ ALU6RotShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA "^"= ALU6Mem is op0=8 & op1=7 & opA & UnpackSR_opA & ALU6Mem  {
    opA = opA ^ ALU6Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
}

# r1 = 7
:^opA = ALU6BaseDisplacement is op0=9 & op1=0 & opA & UnpackSR_opA & ALU6BaseDisplacement  {
    opA = ALU6BaseDisplacement;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = ALU6Opimm is op0=9 & op1=1 & opA & UnpackSR_opA & ALU6Opimm  {
    opA = ALU6Opimm;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = IndirectOp is op0=9 & op1=3 & opA & UnpackSR_opA & IndirectOp  {
    opA = IndirectOp;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = ALU6Reg is op0=9 & op1=4 & opN=0 & opA & UnpackSR_opA & ALU6Reg  {
    opA = ALU6Reg;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = ALU6RShift is op0=9 & op1=4 & opFlag=1 & opA & UnpackSR_opA & ALU6RShift  {
    opA = ALU6RShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = ALU6LShift is op0=9 & op1=5 & opA & UnpackSR_opA & ALU6LShift  {
    opA = ALU6LShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = ALU6RotShift is op0=9 & op1=6 & opA & UnpackSR_opA & ALU6RotShift  {
    opA = ALU6RotShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = ALU6Mem is op0=9 & op1=7 & opA & UnpackSR_opA & ALU6Mem  {
    opA = ALU6Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
}
# r1 |= 7
:^opA |= ALU6BaseDisplacement is op0=0xa & op1=0 & opA & UnpackSR_opA & ALU6BaseDisplacement  {
    opA = opA | ALU6BaseDisplacement;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA |= ALU6Opimm is op0=0xa & op1=1 & opA & UnpackSR_opA & ALU6Opimm  {
    opA = opA | ALU6Opimm;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA |= IndirectOp is op0=0xa & op1=3 & opA & UnpackSR_opA & IndirectOp  {
    opA = opA | IndirectOp;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA |= ALU6Reg is op0=0xa & op1=4 & opN=0 & opA & UnpackSR_opA & ALU6Reg  {
    opA = opA | ALU6Reg;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA |= ALU6RShift is op0=0xa & op1=4 & opFlag=1 & opA & UnpackSR_opA & ALU6RShift  {
    opA = opA | ALU6RShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA |= ALU6LShift is op0=0xa & op1=5 & opA & UnpackSR_opA & ALU6LShift  {
    opA = opA | ALU6LShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA |= ALU6RotShift is op0=0xa & op1=6 & opA & UnpackSR_opA & ALU6RotShift  {
    opA = opA | ALU6RotShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA |= ALU6Mem is op0=0xa & op1=7 & opA & UnpackSR_opA & ALU6Mem  {
    opA = opA | ALU6Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
}
# r1 &= 7
:^opA &= ALU6BaseDisplacement is op0=0xb & op1=0 & opA & UnpackSR_opA & ALU6BaseDisplacement  {
    opA = opA & ALU6BaseDisplacement;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA &= ALU6Opimm is op0=0xb & op1=1 & opA & UnpackSR_opA & ALU6Opimm  {
    opA = opA & ALU6Opimm;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA &= IndirectOp is op0=0xb & op1=3 & opA & UnpackSR_opA & IndirectOp  {
    opA = opA & IndirectOp;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA &= ALU6Reg is op0=0xb & op1=4 & opN=0 & opA & UnpackSR_opA & ALU6Reg  {
    opA = opA & ALU6Reg;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA &= ALU6RShift is op0=0xb & op1=4 & opFlag=1 & opA & UnpackSR_opA & ALU6RShift  {
    opA = opA & ALU6RShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA &= ALU6LShift is op0=0xb & op1=5 & opA & UnpackSR_opA & ALU6LShift  {
    opA = opA & ALU6LShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA &= ALU6RotShift is op0=0xb & op1=6 & opA & UnpackSR_opA & ALU6RotShift  {
    opA = opA & ALU6RotShift;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA &= ALU6Mem is op0=0xb & op1=7 & opA & UnpackSR_opA & ALU6Mem  {
    opA = opA & ALU6Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
}
# test r1, 7
:test opARead, ALU6BaseDisplacement is op0=0xc & op1=0 & opARead & ALU6BaseDisplacement  {
    local res = opARead & ALU6BaseDisplacement;
    setResultFlags(res);
}
:test opARead, ALU6Opimm is op0=0xc & op1=1 & opARead & ALU6Opimm  {
    local res = opARead & ALU6Opimm;
    setResultFlags(res);
}
:test opARead, IndirectOp is op0=0xc & op1=3 & opARead & IndirectOp  {
    local res = opARead & IndirectOp;
    setResultFlags(res);
}
:test opARead, ALU6Reg is op0=0xc & op1=4 & opN=0 & opARead & ALU6Reg  {
    local res = opARead & ALU6Reg;
    setResultFlags(res);
}
:test opARead, ALU6RShift is op0=0xc & op1=4 & opFlag=1 & opARead & ALU6RShift  {
    local res = opARead & ALU6RShift;
    setResultFlags(res);
}
:test opARead, ALU6LShift is op0=0xc & op1=5 & opARead & ALU6LShift  {
    local res = opARead & ALU6LShift;
    setResultFlags(res);
}
:test opARead, ALU6RotShift is op0=0xc & op1=6 & opARead & ALU6RotShift  {
    local res = opARead & ALU6RotShift;
    setResultFlags(res);
}
:test opARead, ALU6Mem is op0=0xc & op1=7 & opARead & ALU6Mem  {
    local res = opARead & ALU6Mem;
    setResultFlags(res);
}
# [bp+7] = r1
:^ALU6DstStack = opARead is op0=0xd & op1=0 & opARead & ALU6DstStack  {
   ALU6DstStack = opARead;
    # does not update flags
}
:^IndirectOp = opARead is op0=0xd & op1=3 & opARead & IndirectOp  {
   IndirectOp = opARead;
}

# [0] = r1
:[opimm] = opARead is op0=0xd & op1=7 & opARead & opimm {
    local addr:3 = opimm;
    *:2 addr = opARead;
}

StackOpA: ""[opARead] is opARead {
    export *:2 opARead;
}
DataOpA: "ds:"[opARead] is opARead {
    local addr:3 = segment(ds, opARead);
    export *:2 addr;
}

# Otherwise cannot be distinguished. Cannot put in directly because
# wrong type (should be family) in pattern equation
with : opA_v!=7 { 
    # Bit Manipulation
    # Test bit
    :tstb opARead, opBitN is op0=0xe & op1=1 & opBitFn=0 & opBitN & opARead {
        local mask = 1 << opBitN;
        Z_flag = (opARead & mask) == 0;
    }
    :tstb StackOpA, opB is op0=0xe & op1=4 & opBitFn=0 & opBitFlg=0 & opB & StackOpA {
        local mask = 1 << opB;
        Z_flag = (StackOpA & mask) == 0;
    }
    :tstb DataOpA, opB is op0=0xe & op1=5 & opBitFn=0 & opBitFlg=0 & opB & DataOpA {
        local mask = 1 << opB;
        Z_flag = (DataOpA & mask) == 0;
    }
    :tstb StackOpA, opBitN is op0=0xe & op1=6 & opBitFn=0 & opBitN & StackOpA {
        local mask = 1 << opBitN;
        Z_flag = (StackOpA & mask) == 0;
    }
    :tstb DataOpA, opBitN is op0=0xe & op1=7 & opBitFn=0 & opBitN & DataOpA {
        local mask = 1 << opBitN;
        Z_flag = (DataOpA & mask) == 0;
    }
    # Set bit
    :setb opARead, opBitN is op0=0xe & op1=1 & opBitFn=1 & opBitN & opARead & UnpackSR_opA { 
        local mask = 1 << opBitN;
        opARead = opARead | mask;
        build UnpackSR_opA;
    }
    :setb StackOpA, opB is op0=0xe & op1=4 & opBitFn=1 & opBitFlg=0 & opB & StackOpA { 
        local mask = 1 << opB;
        StackOpA = StackOpA | mask;
    }
    :setb DataOpA, opB is op0=0xe & op1=5 & opBitFn=1 & opBitFlg=0 & opB & DataOpA { 
        local mask = 1 << opB;
        DataOpA = DataOpA | mask;
    }
    :setb StackOpA, opBitN is op0=0xe & op1=6 & opBitFn=1 & opBitN & StackOpA { 
        local mask = 1 << opBitN;
        StackOpA = StackOpA | mask;
    }
    :setb DataOpA, opBitN is op0=0xe & op1=7 & opBitFn=1 & opBitN & DataOpA { 
        local mask = 1 << opBitN;
        DataOpA = DataOpA | mask;
    }
    # Clear bit
    :clrb opARead, opBitN is op0=0xe & op1=1 & opBitFn=2 & opBitN & opARead & UnpackSR_opA {
        local mask = 1 << opBitN;
        opARead = opARead & ~mask;
        build UnpackSR_opA;
    }
    :clrb StackOpA, opB is op0=0xe & op1=4 & opBitFn=2 & opBitFlg=0 & opB & StackOpA {
        local mask = 1 << opB;
        StackOpA = StackOpA & ~mask;
    }
    :clrb DataOpA, opB is op0=0xe & op1=5 & opBitFn=2 & opBitFlg=0 & opB & DataOpA {
        local mask = 1 << opB;
        DataOpA = DataOpA & ~mask;
    }
    :clrb StackOpA, opBitN is op0=0xe & op1=6 & opBitFn=2 & opBitN & StackOpA {
        local mask = 1 << opBitN;
        StackOpA = StackOpA & ~mask;
    }
    :clrb DataOpA, opBitN is op0=0xe & op1=7 & opBitFn=2 & opBitN & DataOpA {
        local mask = 1 << opBitN;
        DataOpA = DataOpA & ~mask;
    }
    # Toggle bit
    :invb opARead, opBitN is op0=0xe & op1=1 & opBitFn=3 & opBitN & opARead & UnpackSR_opA {
        local mask = 1 << opBitN;
        opARead = opARead ^ mask;
        build UnpackSR_opA;
    }
    :invb StackOpA, opB is op0=0xe & op1=4 & opBitFn=3 & opBitFlg=0 & opB & StackOpA {
        local mask = 1 << opB;
        StackOpA = StackOpA ^ mask;
    }
    :invb DataOpA, opB is op0=0xe & op1=5 & opBitFn=3 & opBitFlg=0 & opB & DataOpA {
        local mask = 1 << opB;
        DataOpA = DataOpA ^ mask;
    }
    :invb StackOpA, opBitN is op0=0xe & op1=6 & opBitFn=3 & opBitN & StackOpA {
        local mask = 1 << opBitN;
        StackOpA = StackOpA ^ mask;
    }
    :invb DataOpA, opBitN is op0=0xe & op1=7 & opBitFn=3 & opBitN & DataOpA {
        local mask = 1 << opBitN;
        DataOpA = DataOpA ^ mask;
    }
}

Bank0Mem: ""[imm16] is imm16 { export *:2 imm16; }

# ALU16
# TODO: this opA_v!=7 isn't true for all cases, should move to specific ALU6Terms after inspection
# with : (op0!=0xf & op0!=0xe & op1=4 & (opN=1 | opN=2 | opN=3)) ... {

# r1 = r2 + 0x1234
# This trickery makes the assembler suggest impossible instructions...
# like [0x1234] = r2 + [0x1234]
# It won't crash or produce invalid machine code. Merely a UX problem
:^opA = opB + imm16 is (op0=0 & op1=4 & opN=1 & opA & UnpackSR_opA & opB) ; imm16 {
	opA = opB + imm16;
    build UnpackSR_opA;
	setResultFlags(opA);
	setAddFlags(opB, imm16);
}
:^opA = opB + Bank0Mem is (op0=0 & op1=4 & opN=2 & opA & UnpackSR_opA & opB) ; Bank0Mem {
	opA = opB + Bank0Mem;
    build UnpackSR_opA;
	setResultFlags(opA);
	setAddFlags(opB, Bank0Mem);
}
:^Bank0Mem = opB + opA is (op0=0 & op1=4 & opN=3 & opA & opB) ; Bank0Mem {
	Bank0Mem = opB + opA;
	setResultFlags(Bank0Mem);
	setAddFlags(opB, opA);
}
# r1 = r2 + 0x1234, carry
:^opA = opB + imm16, "carry" is (op0=1 & op1=4 & opN=1 & opA & UnpackSR_opA & opB) ; imm16 {
    opA = opB + imm16 + zext(C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddCarryFlags(opB, imm16);
}
:^opA = opB + Bank0Mem, "carry" is (op0=1 & op1=4 & opN=2 & opA & UnpackSR_opA & opB) ; Bank0Mem {
    opA = opB + Bank0Mem + zext(C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setAddCarryFlags(opB, Bank0Mem);
}
:^Bank0Mem = opB + opA, "carry" is (op0=1 & op1=4 & opN=3 & opA & opB) ; Bank0Mem {
    Bank0Mem = opB + opA + zext(C_flag);
    setResultFlags(Bank0Mem);
    setAddCarryFlags(opB, opA);
}
# r1 = r2 - 0x1234
:^opA = opB - imm16 is (op0=2 & op1=4 & opN=1 & opA & UnpackSR_opA & opB) ; imm16 {
    opA = opB - imm16;
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractFlags(opB, imm16);
}
:^opA = opB - Bank0Mem is (op0=2 & op1=4 & opN=2 & opA & UnpackSR_opA & opB) ; Bank0Mem {
    opA = opB - Bank0Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractFlags(opB, Bank0Mem);
}
:^Bank0Mem = opB - opA is (op0=2 & op1=4 & opN=3 & opA & opB) ; Bank0Mem {
    Bank0Mem = opB - opA;
    setResultFlags(Bank0Mem);
    setSubtractFlags(opB, opA);
}
# r1 = r2 - 0x1234, carry
:^opA = opB - imm16, "carry" is (op0=3 & op1=4 & opN=1 & opA & UnpackSR_opA & opB) ; imm16 {
    opA = opB - imm16 - zext(!C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractCarryFlags(opB, imm16);
}
:^opA = opB - Bank0Mem, "carry" is (op0=3 & op1=4 & opN=2 & opA & UnpackSR_opA & opB) ; Bank0Mem {
    opA = opB - Bank0Mem - zext(!C_flag);
    build UnpackSR_opA;
    setResultFlags(opA);
    setSubtractCarryFlags(opB, Bank0Mem);
}
:^Bank0Mem = opB - opA, "carry" is (op0=3 & op1=4 & opN=3 & opA & opB) ; Bank0Mem {
    Bank0Mem = opB - opA - zext(!C_flag);
    setResultFlags(Bank0Mem);
    setSubtractCarryFlags(opB, opA);
}
# cmp r2, 0x1234
:cmp opB, imm16 is (op0=4 & op1=4 & opN=1 & opA & opB) ; imm16 {
    local res = opB - imm16;
    setResultFlags(res);
    setSubtractCarryFlags(opB, imm16);
}
:cmp opB, Bank0Mem is (op0=4 & op1=4 & opN=2 & opA & opB) ; Bank0Mem {
    local res = opB - Bank0Mem;
    setResultFlags(res);
    setSubtractCarryFlags(opB, Bank0Mem);
}
# r1 = -0x1234
:^opA = -imm16 is (op0=6 & op1=4 & opN=1 & opA & UnpackSR_opA) ; imm16 {
    opA = -imm16;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = -Bank0Mem is (op0=6 & op1=4 & opN=2 & opA & UnpackSR_opA) ; Bank0Mem {
    opA = -Bank0Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^Bank0Mem = -opARead is (op0=6 & op1=4 & opN=3 & opARead) ; Bank0Mem {
    Bank0Mem = -opARead;
    setResultFlags(Bank0Mem);
}
# r1 = r2 ^ 0x1234
:^opA = opB "^" imm16 is (op0=8 & op1=4 & opN=1 & opA & UnpackSR_opA & opB) ; imm16 {
    opA = opB ^ imm16;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = opB "^" Bank0Mem is (op0=8 & op1=4 & opN=2 & opA & UnpackSR_opA & opB) ; Bank0Mem {
    opA = opB ^ Bank0Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^Bank0Mem = opB "^" opARead is (op0=8 & op1=4 & opN=3 & opARead & opB) ; Bank0Mem {
    Bank0Mem = opB ^ opARead;
    setResultFlags(Bank0Mem);
}
# r1 = 0x1234
:^opA = imm16 is (op0=9 & op1=4 & opN=1 & opA & UnpackSR_opA) ; imm16 {
    opA = imm16;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^"pc" = imm16 is (op0=9 & op1=4 & opN=1 & opA_v=7) ; imm16 {
	local off:2 = imm16;
	# inst_start is 8 bit byte, not word offset, need to load PC with word offset
	local addr:3= ((inst_start >> 1) & 0xff0000) | zext(off);
    setResultFlags(off);
    goto [addr];
}
:^opA = Bank0Mem is (op0=9 & op1=4 & opN=2 & opA & UnpackSR_opA) ; Bank0Mem {
    opA = Bank0Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^Bank0Mem = opARead is (op0=9 & op1=4 & opN=3 & opARead) ; Bank0Mem {
    Bank0Mem = opARead;
    setResultFlags(Bank0Mem);
}
# r1 = r2 | 0x1234
:^opA = opB | imm16 is (op0=0xa & op1=4 & opN=1 & opA & UnpackSR_opA & opB) ; imm16 {
    opA = opB | imm16;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = opB | Bank0Mem is (op0=0xa & op1=4 & opN=2 & opA & UnpackSR_opA & opB) ; Bank0Mem {
    opA = opB | Bank0Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^Bank0Mem = opB | opARead is (op0=0xa & op1=4 & opN=3 & opARead & opB) ; Bank0Mem {
    Bank0Mem = opB | opARead;
    setResultFlags(Bank0Mem);
}
# r1 = r2 & 0x1234
:^opA = opB & imm16 is (op0=0xb & op1=4 & opN=1 & opA & UnpackSR_opA & opB) ; imm16 {
    opA = opB & imm16;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^opA = opB & Bank0Mem is (op0=0xb & op1=4 & opN=2 & opA & UnpackSR_opA & opB) ; Bank0Mem {
    opA = opB & Bank0Mem;
    build UnpackSR_opA;
    setResultFlags(opA);
}
:^Bank0Mem = opB & opARead is (op0=0xb & op1=4 & opN=3 & opARead & opB) ; Bank0Mem {
    Bank0Mem = opB & opARead;
    setResultFlags(Bank0Mem);
}
# test r2, 0x1234
# Note: xasm16 says using SR as source register is illegal
:test opB_nosr, imm16 is (op0=0xc & op1=4 & opN=1 & opA & opB_nosr) ; imm16 {
    local res = opB_nosr & imm16;
    setResultFlags(res);
}
:test opB_nosr, Bank0Mem is (op0=0xc & op1=4 & opN=2 & opA & opB_nosr) ; Bank0Mem {
    local res = opB_nosr & Bank0Mem;
    setResultFlags(res);
}
# [0x1234] = r2
:^Bank0Mem = opB is (op0=0xd & op1=4 & opN=3 & opB) ; Bank0Mem {
    Bank0Mem = opB;
    # does not update flags
}

# Interrupts, nop, and others
# TODO opA == 0 ??
# TODO Basing this on opimm isn't right...
# Seems to switch on opB (literal not register)
# Revisit
with : op1=5 & op0=0xf {
    :int "off" is opimm=0x00 {
        irq = 0;
        fiq = 0;
    }
    :int "irq" is opimm=0x01 {
        irq = 1;
        fiq = 0;
    }
    :int "fiq" is opimm=0x02 {
        irq = 0;
        fiq = 1;
    }
    :int "fiq,irq" is opimm=0x03 {
        irq = 1;
        fiq = 1;
    }
    :fir_mov "on" is opimm=0x04 {
        fir_mov = 0;
    }
    :fir_mov "off" is opimm=0x05 {
        fir_mov = 1;
    }
    :fraction "off" is opimm=0x06 {
        fraction = 0;
    }
    :fraction "on" is opimm=0x07 {
        fraction = 1;
    }
    :irq "off" is opimm=0x08 {
        irq = 0;
    }
    :irq "on" is opimm=0x09 {
        irq = 1;
    }
    :secbank "off" is opimm=0x0a {
        sec_bank = 0;
    }
    :secbank "on" is opimm=0x0b {
        sec_bank = 1;
    }
    :fiq "off" is opimm=0x0c {
        fiq = 0;
    }
    :irqnest "off" is opimm=0x0d {
        irqnest = 0;
    }
    :fiq "on" is opimm=0x0e {
        fiq = 1;
    }
    :irqnest "on" is opimm=0x0f {
        irqnest = 1;
    }
    :"break" is opimm=0x20 unimpl
    :"call mr" is opimm=0x21 {
        push(pc);
        push(sr);

        local addr:3 = segment(r4 & 0x3f, r3);
        call [addr];
    }
    :^"r2 =" "exp" "r4" is opimm=0x24 {
        exp(r2, r4);
    }
    :"nop" is opimm=0x25 {
        # To suppress NOP warning
        local NOP:1 = 0;
        NOP = NOP;
    }
}

# Extra Shifts
with : op0=0xe & opE1=2 & opBitFlg=1 {
    # 1110|***|100|00|1|***
    :^opARead "asr" opB is opE2=0 & opARead & UnpackSR_opA & opB {
        opARead = opARead s>> opB;
        build UnpackSR_opA;
    }
    # 1110|***|100|10|1|***
    :^opARead "lsl" opB is opE2=2 & opARead & UnpackSR_opA & opB {
        opARead = opARead << opB;
        build UnpackSR_opA;
    }
    # 1110|***|101|00|1|***
    :^opARead "lsr" opB is opE2=4 & opARead & UnpackSR_opA & opB {
        opARead = opARead >> opB;
        build UnpackSR_opA;
    }
    # 1110|***|100|01|1|***
    :^"r3,r4" |= opARead "asror" opB is opE2=1 & opARead & opB {
        if(opB==0) goto inst_next;
        local full:4 = sext(opARead) << 16;
        full = full s>> opB;
        r3 = r3 | full:2;
        r4 = opARead s>> opB;
    }
    # 1110|***|10|01|11|***
    # Might change display
    :^"r3,r4" |= opARead "lslor" opB is opE2=3 & opARead & opB {
        if(opB==0) goto inst_next;
        local full:4 = zext(opARead) << opB;
        r4 = r4 | full(2);
        r3 = opARead << opB;
    }
    # 1110|***|10|10|11|***
    :^"r3,r4" |= opARead "lsror" opB is opE2=5 & opARead & opB {
        if(opB==0) goto inst_next;
        local full:4 = zext(opARead) << 16;
        full = full >> opB;
        r3 = r3 | full:2;
        r4 = opARead >> opB;
    }
}

# Multiplication
# 1110|***|00|00|01|***
:"mr" = opA*opB, "uu" is op0=0xe & op1=0x0 & opN=0x1 & opA_v!=7 & opA & opB {
    local res:4 = zext(opA) * zext(opB);
    r4 = res(2);
    r3 = res:2;
}
# 1111|***|00|00|01|***
:"mr" = opA*opB, "us" is op0=0xf & op1=0x0 & opN=0x1 & opA_v!=7 & opA & opB {
    local res:4 = zext(opA) * sext(opB);
    r4 = res(2);
    r3 = res:2;
}
# 1111|***|10|00|01|***
:"mr" = opA*opB, "ss" is op0=0xf & op1=0x4 & opN=0x1 & opA_v!=7 & opA & opB {
    local res:4 = sext(opA) * sext(opB);
    r4 = res(2);
    r3 = res:2;
}

# TODO: inner product, division

# Other
# 1111|111|000|******
:^"ds" = opimm is op0=0xf & op1=0 & opA_v=7 & opimm {
    ds = opimm;
}
# 1111|***|000|101|***
:^"ds" = opB_nosr is op0=0xf & op1=0 & opA_v!=7 & opN=5 & opB_nosr {
    ds = opB_nosr:1 & 0x3f;
}
# 1111|***|000|100|***
:^opB_nosr = "ds" is op0=0xf & op1=0 & opA_v!=7 & opN=4 & opB_nosr {
    opB_nosr = zext(ds & 0x3f);
}
# 1111|***|000|111|***
:^"fr" = opB_nosr is op0=0xf & op1=0 & opA_v!=7 & opN=7 & opB_nosr {
    fr = opB_nosr;
}
# 1111|***|000|110|***
:^opB_nosr = "fr" is op0=0xf & op1=0 & opA_v!=7 & opN=6 & opB_nosr {
    opB_nosr = fr;
}

# Calls
call_addr: addr is opimm & op1=1 & op0=0xf; imm16 [ addr=(opimm << 16) | imm16; ] { export *[ram]:3 addr; }

:call call_addr is call_addr {
    push(inst_next);
    push(sr);

    call call_addr;
}

goto_addr: addr is op1=2 & op0=0xf & opimm ; imm16 [ addr=(opimm << 16) | imm16; ] { export *[ram]:3 addr; } 

:goto goto_addr is goto_addr {
    goto goto_addr;
}

:goto "mr" is op1=3 & op0=0xf {
    local addr:3 = segment(r4 & 0x3f, r3);
    goto [addr];
}

# TODO tricky to implement, will partially implement for now
:pop opA_p "from" [opB] is op1=2 & op0=9 & opN=1 & opA_p & opB {
    opB = opB + 1;
    local stack_addr:3 = segment(0:1, opB);
    opA_p = *:2 stack_addr;
}
# pop pc, sr from [sp]
:retf is op1=2 & op0=9 & opA_v=5 & opN=2 & opB_v=0 & UnpackSR {
    sp = sp + 1;
    local stack_addr:3 = segment(0:1, sp);
    sr = *:2 stack_addr;
    build UnpackSR;
    sp = sp + 1;
    stack_addr = segment(0:1, sp);
    local pc_low:2 = *:2 stack_addr;
    local addr:3 = segment(cs, pc_low);
    return [addr];
}

:pop "pc", "bp" "from" ["sp"] is op1=2 & op0=9 & opA_v=4 & opN=3 & opB_v=0 & UnpackSR {
    sp = sp + 1;
    local stack_addr:3 = segment(0:1, sp);
    bp = *:2 stack_addr;
    sp = sp + 1;
    stack_addr = segment(0:1, sp);
    sr = *:2 stack_addr;
    build UnpackSR;
    sp = sp + 1;
    stack_addr = segment(0:1, sp);
    local pc_low:2 = *:2 stack_addr;
    local addr:3 = segment(cs, pc_low);
    return [addr];
}

:pop opA,opN "from" [opB] is op1=2 & op0=9 & opN & opA & opB {
    # TODO
    sp = sp + opN;
}

:push opA "to" [opB] is op1=2 & op0=0xd & opN=1 & opB & opA {
    local stack_addr:3 = segment(0:1, opB);
    *:2 stack_addr = opA;
    opB = opB - 1;
}

# TODO replace opN, define properly in action section
:push opA,opN "to" [opB] is op0=0xd & op1=2 & opA & opN & opB {
    # TODO
    sp = sp - opN;
}

# u'nSP 2.0 extended instructions
#:^instruction is isExtended=0 & opFull=0xff80 & instruction [ isExtended=1; ] { }
#
#with : isExtended=1 {
#    # TODO
#}
